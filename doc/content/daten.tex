\section{Verarbeitung der Daten}

Bevor das Diagramm im Browser dargestellt werden kann, müssen zuerst die Daten geladen verarbeitet werden. Die Beispiele dieser Arbeit nutzen grösstenteils Datensätze, die frei verfügbar sind.  %hier näher erklären TODO
Die Diagramme in Abbildung \ref{fig:scatterplot} benutzen einen Datensatz der Weltbank, der den $CO_2$-Verbrauch von Afghanistan beinhaltet.

Beim Prozess zur Veranschaulichung von Daten wird die \textit{Visualisierungspipeline} durchlaufen \cite{pipeline}. Diese Pipeline stellt drei wesentliche Schritte des Prozesses dar: Die Datenaufbereitung (\textit{Filtering}), die Erzeugung des Geometriemodells (\textit{Mapping}) und die Bildgenerierung (\textit{Rendering}).

% = rohdaten -> aufbereitete Daten -> geometriedaten -> Bilddaten

\subsection{Rohdaten}

\subsubsection{Comma-seperated values (CSV)}

Die Software verwendet als Datenformat \textit{Comma-seperated values} (\textit{CSV}). CSV stellt eine Tabelle dar. Zeilen werden im Format durch einen Umbruch und Spaltenwerte durch ein Komma getrennt. Optional steht in der ersten Zeile (Abbildung \ref{fig:csv} links, Zeile 1) der Datei die Beschriftung der Spalten.

In Abbildung \ref{fig:csv} wird die Funktion des CSV-Formats demonstriert.

\begin{figure}[!htbp]
	\centering
	\begin{minipage}{0.5\textwidth}
		\centering
		\begin{minted}{text}
Date,Value
2010-12-31,4220.717
2009-12-31,4352.729
2008-12-31,5555.505
2007-12-31,5067.794
		\end{minted}
	\end{minipage}\hfill
	\begin{minipage}{0.5\textwidth}
		\centering
		\begin{tabular}{ | l | l |}
			\hline
			\textbf{Date} & \textbf{Value} \\ \hline
			2010-21-31 & 4220.717 \\ \hline
			2009-21-31 & 4352.729 \\ \hline
			2008-21-31 & 5555.505 \\ \hline
			2007-21-31 & 5067.794 \\ \hline
		\end{tabular}
	\end{minipage}
	\caption[Demonstration des CSV-Formats]{Demonstration des CSV-Formats. Links: Die CSV-Datei in Rohtext. Rechts: Darstellung der Informationen der CSV-Datei in einer Tabelle.}
	\label{fig:csv}
\end{figure}

Man verwendet das CSV-Format oft, weil es sehr einfach aufgebaut ist. Das Lesen von solchen Tabellenformaten ist ohne grossen Aufwand in Programmen umsetzbar. 

 Zudem beschränkt sich das CSV-Format nur auf die Vermittlung der Daten, und beinhaltet keine Informationen zu der Darstellung der Tabelle. Excel-Dateien (XLS/XLSX) hingegen speichern auch Daten zu der Formatierung, auch Zeilengrösse, Textgrösse, Textformat und viele mehr. Für die Zwecke dieser Software sind diese Informationen irrelevant.
 
 
Wenn die Software die CSV-Datei laden und verarbeiten will, dann braucht sie zunächst zusätzliche Informationen zu der Datei: Die \textit{URL}, die den Ort der Datei angibt.

Die Software lädt die Datei durch eine \textit{Ajax}-Anfrage (\textit{Asynchronous JavaScript and XML}) herunter, bevor sie sie weiter verarbeitet.

\subsection{Filtering}

Das Filtering ist der Prozess, der Rohdaten in aufbereitete Daten umwandelt. Die Aufgaben des Filterings sind zum Beispiel die Vervollständigung, Reduzierung, Korrektur der Daten, sodass sie in den folgenden Schritten der Visualisationspipeline verwendet werden können \cite[Kap. 2]{viz}.

\subsubsection{Konvertierung in JavaScript Objects}

Als erster Schritt wird in der Applikation die CSV-Datei in \textit{JavaScript-Objekte} umgewandelt. Das Laden und \textit{Parsing} der Datei von CSV zu Objekten ist von D3 implementiert.

JavaScript Objekte werden im \textit{JavaScript Object Notation}-Format (\textit{JSON}) dargestellt.

Im Abbildung \ref{fig:csv-json} ist der Prozess der Umwandlung ersichtlich: Es wird ein \textit{Array} von allen Zeilen in der Tabelle (ausgenommen der ersten Zeile, wo die Spalten beschriftet werden) erstellt. Jede Zeile wird als Objekt mit den dazugehörigen Spalten dargestellt.

\begin{figure}[!htbp]
	\centering
	\begin{minipage}{0.35\textwidth}
		\centering
		\begin{minted}{text}
Date,Value
2010-12-31,4220.717
2009-12-31,4352.729
2008-12-31,5555.505
2007-12-31,5067.794
		\end{minted}
	\end{minipage}\hfill
	\begin{minipage}{0.55\textwidth}
		\centering

		\begin{minted}{json}
[
  {
    "Date": "2010-12-31",
    "Value": "4220.717"
  },
  {
    "Date": "2009-12-31",
    "Value": "4352.729"
  },
  {
    "Date": "2008-12-31",
    "Value": "5555.505"
  },
  {
    "Date": "2007-12-31",
    "Value": "5067.794"
  }
]
		\end{minted}
	\end{minipage}
	\caption[CSV und JSON]{Konvertierung von CSV zu JavaScript Objekten. Links: CSV. Rechts: JSON.}
	\label{fig:csv-json}
\end{figure}

\subsubsection{Formatierung}

Die Software benötigt nun Anweisungen, um den Datensatz (im JSON-Format) zu formatieren, damit er im Diagramm verwendet werden kann. Der Prozess muss folgende Aufgaben erledigen:

\begin{itemize}
	\item (Zeichenstring-) Elemente gegebenfalls in JavaScript-Objekte umwandeln
	\item Falls mehrere Datensätze vorhanden sind, diese \textit{mergen}, also in einen einzigen Array zusammenfassen
	\item Den gesamten gemergten Datensatz nach der unabhängigen Variable aufsteigend sortieren
\end{itemize}

\textbf{Umwandlung zu JavaScript-Objekten.} Das CSV-Format unterscheidet nicht zwischen Datentypen. Alle Werte in CSV-Dateien sind Zeichenstrings.

In dem Beispiel in der Abbildung \ref{fig:csv-json} rechts, Zeile 3 wird für das erste Objekt im Array das Attribut mit dem Namen "`Date"' definiert. Der Datentyp ist hier ein Zeichenstring, eine Umwandlung in das JavaScript-Date-Objekt, das ein Datum darstellt, ist sinnvoll: Das JavaScript Date-Objekt beherrscht viele Funktionen, wie zum Beispiel die Ausgabe der Anzahl Millisekunden, die seit dem 1. Januar 1970 vergangen sind. Dies ist beim Vergleichen von verschiedenen Date-Objekten nützlich. Das Date-Objekt ist zum Beispiel auch fähig, das Datum in einem Format auszugeben, das den lokalen Konventionen entspricht: 28.10.2015 (Schweiz), 10/28/2015 (USA).

Nummern, wie in Abbildung \ref{fig:csv-json} rechts, Zeile 4, im Attribut mit dem Namen "`Value"' definiert, wandeln wir in Nummern um. Nur an Nummer-Objekten können Rechenoperationen durchgeführt werden.

\textbf{Merging von Datensätzen.} Oft werden mehrere Datensätze in der Software geladen. Ein Beispiel ist der $CO_2$-Verbrauch von Ländern: Für jedes Land wird eine separate CSV-Datei geladen und in ein JavaScript-Array umgewandelt.

Ich entschieden, alle geladenen Datensätze (Arrays) in ein Datensatz (Array) zusammenzufassen (\textit{merge}), weil dies für die Programmlogik mehr Sinn macht.

Da Spalten von verschiedenen Datensätzen meist mit gleichem Namen beschriftet sind, könnte man nach dem Merge die Spalten nicht unterscheiden (Abbildung \ref{fig:merge} oben). Darum wird die Beschriftung aller Spalten der abhängigen Variablen durch eine eindeutige ID ersetzt (Abbildung \ref{fig:merge} unten). Die eindeutige ID wird durch den Spaltennamen und die URL der Datensatzes generiert: Der Spaltennamen wird ein Rautenzeichen und die URL angehängt. Dies ermöglicht, dass man trotz Merge die Objekte dem herkömmlichen Datensatz zuordnen kann.

In der Abbildung \ref{fig:merge} wurden zwei Datensätze mit dem Dateinamen ch-co2.csv und af-co2.csv gemergt. Im unteren Beispiel wurden die Spaltennamen der abhängigen Variablen durch die eindeutige ID ersetzt.

\begin{figure}[!htbp]
	\centering
	\begin{minipage}{0.40\textwidth}
		\centering
		\begin{minted}{json}
[
  {
    "Date": "2010-12-31",
    "Value": "4220.717"
  },
  {
    "Date": "2009-12-31",
    "Value": "4352.729"
  },
  {
    "Date": "2010-12-31",
    "Value": "1320.717"
  },
  {
    "Date": "2009-12-31",
    "Value": "7353.129"
  }
]
		\end{minted}
	\end{minipage}\hfill
	\begin{minipage}{0.5\textwidth}
		\centering
		\begin{minted}{json}
[
  {
    "Date": "2010-12-31",
    "Value#ch-co2.csv": "4220.717"
  },
  {
    "Date": "2009-12-31",
    "Value#ch-co2.csv": "4352.729"
  },
  {
    "Date": "2010-12-31",
    "Value#af-co2.csv": "1320.717"
  },
  {
    "Date": "2009-12-31",
    "Value#af-co2.csv": "7353.129"
  }
]
		\end{minted}
	\end{minipage}
	\caption[Merge-Strategie]{Demonstration der Merge-Strategie und Anwendung der ID-Generierung. Oben: Gemergter Datensatz, ohne eindeutige IDs. Unten: Gemergter Datensatz, mit eindeutigen IDs.}
	\label{fig:merge}
\end{figure}

\textbf{Sortieren vom gemergten Datensatz.} Der Datensatz wird nach der unabhängigen Variable ansteigend sortiert, damit die Berechnung von Interpolationen ermöglicht werden.

\subsubsection{Datensatzspezifische Konfiguration und Hard Coding}

\subsection{Aufbereitete Daten}

\subsection{Mapping}

\subsection{Geometriedaten}

\subsection{Rendering}

\subsection{Bilddaten}